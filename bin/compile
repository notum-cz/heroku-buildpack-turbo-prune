#!/usr/bin/env bash
set -euo pipefail

# Heroku buildpack compile args:
#   $1 = build dir, $2 = cache dir, $3 = env dir (config vars materialized as files)
BUILD_DIR="$1"
CACHE_DIR="$2"
ENV_DIR="$3"

# Load Heroku config vars (files) into env:
# Heroku exposes config vars as files in $ENV_DIR; filename becomes the env var name.
if [[ -d "$ENV_DIR" ]]; then
  for e in "$ENV_DIR"/*; do
    [[ -f "$e" ]] || continue
    export "$(basename "$e")"="$(cat "$e")"
  done
fi

# Workspace must be provided (e.g. @repo/ui, @repo/strapi) to determine what to prune/build.
WORKSPACE="${WORKSPACE:-}"
if [[ -z "$WORKSPACE" ]]; then
  echo "Missing WORKSPACE (e.g. @repo/ui). Aborting." >&2
  exit 1
fi

# App must be provided (e.g. ui or strapi) to locate its root (for Procfile, app.json etc).
APP="${APP:-}"
if [[ -z "$APP" ]]; then
  echo "Missing APP (e.g. ui). Aborting." >&2
  exit 1
fi

cd "$BUILD_DIR"

# Pin turbo version (override via TURBO_VERSION env var).
TURBO_VERSION="${TURBO_VERSION:-2.7.3}"

# Temp workspace for downloads and pruned output. Always cleaned up on exit.
TMP="$(mktemp -d)"
trap 'rm -rf "$TMP"' EXIT

# --- TURBO DOWNLOAD AND PRUNE

download_turbo() {
  # Download the platform-specific turbo binary tarball and return the extracted binary path.
  local url root_dir pkgdir turbo_bin
  url="https://registry.npmjs.org/turbo-linux-64/-/turbo-linux-64-${TURBO_VERSION}.tgz"

  echo "Downloading turbo from: $url..." >&2
  curl -fsSL "$url" -o "$TMP/turbo.tgz"

  # npm tarballs typically contain a single top-level directory; capture it for extraction paths.
  root_dir="$(tar -tzf "$TMP/turbo.tgz" | head -n 1 | cut -d/ -f1)"
  tar -xzf "$TMP/turbo.tgz" -C "$TMP"

  pkgdir="$TMP/$root_dir"

  # Try common binary locations first; fall back to a broader search if needed.
  turbo_bin=""
  for candidate in \
    "$pkgdir/bin/turbo" \
    "$pkgdir/bin/turbo-linux-64" \
    "$pkgdir/turbo" \
    "$pkgdir/turbo-linux-64"
  do
    if [[ -f "$candidate" ]]; then
      turbo_bin="$candidate"
      break
    fi
  done

  if [[ -z "$turbo_bin" ]]; then
    turbo_bin="$(find "$pkgdir" -maxdepth 3 -type f \( -name turbo -o -name 'turbo-linux-*' -o -name 'turbo-*' \) | head -n 1 || true)"
  fi

  if [[ -z "$turbo_bin" ]]; then
    echo "Could not find turbo binary after extracting: $url" >&2
    exit 1
  fi

  chmod +x "$turbo_bin"
  echo "$turbo_bin"
}

# Always materialize strapi-types/generated if inputs exist.
# This keeps the generated .d.ts files available after pruning for downstream packages that expect them.
if [[ -d "packages/strapi-types" ]] && compgen -G "apps/strapi/types/generated/*.d.ts" >/dev/null; then
  rm -rf "packages/strapi-types/generated"
  mkdir -p "packages/strapi-types/generated"
  cp -f apps/strapi/types/generated/*.d.ts "packages/strapi-types/generated/"
fi

TURBO_BIN="$(download_turbo)"

# Disable turbo global warnings about being run as standalone binary before the Node buildpack runs.
export TURBO_GLOBAL_WARNING_DISABLED=1

# Run turbo prune to create a minimal workspace for the requested scope.
rm -rf out
"$TURBO_BIN" prune "$WORKSPACE" --docker

# Move the `out/` directory aside before wiping the repo working tree.
mv out "$TMP/out"

# Replace build dir with pruned tree contents.
rm -rf ./* ./.??* ./.?* 2>/dev/null || true
tar -C "$TMP/out/full" -cf - . | tar -C "$BUILD_DIR" -xf -
# Copy the pruned lockfile produced by `turbo prune`.
# (turbo writes the lockfile next to `out/`, not inside `out/full/`.)
for lockfile in yarn.lock pnpm-lock.yaml package-lock.json; do
  if [[ -f "$TMP/out/$lockfile" ]]; then
    cp -f "$TMP/out/$lockfile" "$BUILD_DIR/$lockfile"
  fi
done

echo "turbo-prune: scope=$WORKSPACE turbo=$TURBO_VERSION"

# --- HEROKU CONFIG AND ARTIFACTS
# Heroku only reads these files from the build root, so copy them from the app folder after prune.

APP_ROOT="${BUILD_DIR}/apps/${APP}"
if [[ ! -d "$APP_ROOT" ]]; then
  echo "App directory not found: $APP_ROOT (APP=$APP)" >&2
  exit 1
fi

# Procfile (required)
PROCFILE_SRC="$APP_ROOT/Procfile"
if [[ ! -f "$PROCFILE_SRC" ]]; then
  echo "Procfile not found in: $APP_ROOT" >&2
  exit 1
fi
cp -f "$PROCFILE_SRC" "$BUILD_DIR/Procfile"
echo "Copied $PROCFILE_SRC -> Procfile" >&2

# .slugignore (optional, but recommended to keep slug small)
if [[ -f "$APP_ROOT/.slugignore" ]]; then
  cp -f "$APP_ROOT/.slugignore" "$BUILD_DIR/.slugignore"
  echo "Copied $APP_ROOT/.slugignore -> .slugignore" >&2
fi

# app.json (optional Heroku metadata)
if [[ -f "$APP_ROOT/app.json" ]]; then
  cp -f "$APP_ROOT/app.json" "$BUILD_DIR/app.json"
  echo "Copied $APP_ROOT/app.json -> app.json" >&2
fi